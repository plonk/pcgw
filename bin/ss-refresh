#!/usr/bin/env ruby
# スクリーンショット更新スクリプト

APP_DIR = File.dirname File.dirname File.absolute_path(__FILE__)
Dir.chdir(APP_DIR)

require_relative '../init'
require_relative '../models/init'
require_relative '../logging'

Logging.logger = Logger.new('log/pcgw.log', 'daily')

require 'shellwords'
require 'timeout'

Signal.trap(:TERM) { puts 'TERM trapped' }

class ScreenShotRefresh
  include Logging

  def initialize
  end

  def command(channel, output)
    case channel.channel_info.stream_type
    when 'FLV' then "ffmpeg -i http://#{channel.servent.hostname}:#{channel.servent.port}/stream/#{channel.gnu_id} -y -vf \"select='eq(pict_type,PICT_TYPE_I)'\" -vsync vfr -vframes 1 #{Shellwords.escape(output)}"
    when 'WMV' then "ffmpeg -i mmsh://#{channel.servent.hostname}:#{channel.servent.port}/stream/#{channel.gnu_id} -y -vf \"select='eq(pict_type,PICT_TYPE_I)'\" -vsync vfr -vframes 1 #{Shellwords.escape(output)}"
    else "" end
  end

  def capture(channel, output)
    cmd = command(channel, output)
    log.debug "executing #{cmd.inspect}"

    pid = spawn(cmd)
    Timeout.timeout(30) do
      Process.waitpid(pid)
      log.info "exit status #{$?}"
      if $? != 0
	return false
      end
    end
    return File.exist?(output)
  rescue Timeout::Error
    # ffmpeg がダウンロードを開始すると 1 回の SIGTERM では死なないので
    # 2 回送る。
    2.times do
      Process.kill('-SIGTERM', Process.getpgid(pid))
      sleep 0.1
    end
    # 子供の死を看取る
    Process.waitpid(pid)
    log.error('timed out')
    return false
  end

  def screen_shot_dir
    APP_DIR + '/public/screen_shots'
  end

  def random_128bit
    32.times.map { rand(16).to_s(16).upcase }.join
  end


  def run
    FileUtils.mkdir_p screen_shot_dir

    n = Channel.all.to_a.count do |ch|
      while true
        filename = "#{random_128bit}.jpg"
        path = "#{screen_shot_dir}/#{filename}"
        break unless File.exist? path
      end

      success = capture(ch, path)
      if success
        system("convert -resize 300x10000 -strip #{path} #{path}")
        screen_shot = ch.channel_info.screen_shots.build(filename: filename)
        screen_shot.save!
      end
      success
    end
    log.info("took #{n} shots of #{Channel.all.count} channels")

  end

end

app = ScreenShotRefresh.new
app.run
